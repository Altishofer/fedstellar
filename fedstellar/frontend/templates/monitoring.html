{% extends "layout.html" %}
{% block page_title %}Scenario Monitoring{% endblock %}
{% block body %}
{{ super() }}

<h4>Monitor scenario using Fedstellar</h4>
<hr>

{% if not scenario %}

<h4>There are no scenario named {{ scenario_name }}.</h4>

{% else %}

<h3>Scenario</h3>
<h5>Scenario name: <b id="scenario_name">{{ scenario[0] }}</b></h5>
<h5>Scenario title: <b id="scenario_title">{{ scenario[3] }}</b></h5>
<h5>Scenario description: <b id="scenario_description">{{ scenario[4] }}</b></h5>
<h5>Scenario start time: <b id="scenario_start_time">{{ scenario[1] }}</b></h5>
<h5>Scenario end time: <b id="scenario_end_time">{{ scenario[2] }}</b></h5>
{% if scenario[5] == "running" %}
<h5>Scenario status: <span id="scenario_status" class="label label-success">Running</span></h5>
<a href="{{ url_for('fedstellar_stop_scenario', scenario_name=scenario[0]) }}" class="btn btn-danger">Stop scenario</a>
{% elif scenario[5] == "completed" %}
<h5>Scenario status: <span id="scenario_status" class="label label-info">Completed</span></h5>
<a href="{{ url_for('fedstellar_stop_scenario', scenario_name=scenario[0]) }}" class="btn btn-danger">Stop scenario</a>
{% else %}
<h5>Scenario status: <span id="scenario_status" class="label label-danger">Finished</span></h5>
{% endif %}

<a href="{{ url_for('fedstellar_scenario_statistics', scenario_name=scenario[0]) }}" class="btn btn-dark">Real-time
    metrics</a>
<a href="{{ url_for('fedstellar_scenario_private', scenario_name=scenario[0]) }}" class="btn btn-dark">Private page</a>
<hr>

<h3>Nodes in the database</h3>
<p class="text-muted">The following table shows the nodes that are in the database. The nodes that are online are marked
    with a green label.</p>
<p class="text-muted"><u>Important:</u> The nodes can take up to ~3 minutes to appear in the table. Please refresh the
    page if they do not appear.</p>

<div class="table-responsive">
    <table id="table-nodes" class="table small">
        <thead>
            <tr>
                <th>UID</th>
                <th>IDX</th>
                <th>IP</th>
                <th>Port</th>
                <th>Role</th>
                <th>Neighbors</th>
                <th>Latitude</th>
                <th>Longitude</th>
                <th>Timestamp</th>
                <th>Federation</th>
                <th>Round</th>
                <th>Status</th>
                <th>Logs</th>

            </tr>
        </thead>
        {% for uid, idx, ip, port, role, neighbors, latitude, longitude, timestamp, federation, round, scenario, status
        in nodes %}
        <tr id="node-{{ uid }}">
            <td id="uid"> {{ uid }}</td>
            <td id="idx"> {{ idx }}</td>
            <td id="ip"> {{ ip }}</td>
            <td id="port"> {{ port }}</td>
            <td id="role"> {{ role }}</td>
            <td id="neighbors"> {{ neighbors }}</td>
            <td id="latitude">{{ latitude }}</td>
            <td id="longitude">{{ longitude }}</td>
            <td id="timestamp"> {{ timestamp }}</td>
            <td id="federation"> {{ federation }}</td>
            <td id="round"> {{ round }}</td>
            {% if status %}
            <td id="status"><span class="label label-success">Online</span></td>
            {% else %}
            <td id="status"><span class="label label-danger">Offline</span></td>
            {% endif %}
            <td class="td-icons" id="logs">
                <div class="dropdown">
                    <button class="btn btn-secondary dropdown-toggle" type="button" id="dropdownMenuButton"
                        data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                        <i class="fa fa-bars"></i>
                    </button>
                    <div class="dropdown-menu" aria-labelledby="dropdownMenuButton">
                        <a class="dropdown-item" href="#" style="pointer-events: none;">
                            <input type="checkbox" class="form-check-input" id="logicon" style="pointer-events: all">
                            Show logs
                        </a>
                        <a class="dropdown-item download" href="/scenario/{{ scenario_name }}/node/{{ idx }}/infolog">
                            <i class="fa fa-download"></i>
                            Download INFO logs
                        </a>
                        <a class="dropdown-item download" href="/scenario/{{ scenario_name }}/node/{{ idx }}/debuglog">
                            <i class="fa fa-download"></i>
                            Download DEBUG logs
                        </a>
                        <a class="dropdown-item download" href="/scenario/{{ scenario_name }}/node/{{ idx }}/errorlog">
                            <i class="fa fa-download"></i>
                            Download ERROR logs
                        </a>
                    </div>
                </div>
            </td>
        </tr>
        <tr class="dropdown-content" style="display: none;">
            <td colspan="12">
                <div id="logscontainer" data-id="{{ idx }}" data-scenario="{{ scenario_name }}">
                    <p id="logstext" style="color: black; font-weight: bold"></p>
                </div>
            </td>
        </tr>
        {% endfor %}
    </table>
</div>

<h3>Map</h3>
<p class="text-muted">This functionality enables you to visualize the nodes in a real-time map. Click on a node to see
    its details.</p>

<div class="row">
    <div id="map"></div>
</div>


<h3>Topology Image</h3>
<p class="text-muted">This functionality enables you to generate a topology image of the scenario. The image is
    generated using the following button.</p>
<a class="btn btn-dark" style="padding: 10px;margin-bottom: 10px"
    href="{{ url_for('fedstellar_monitoring_image', scenario_name=scenario[0]) }}">Download topology</a>

<h3>Topology 3D</h3>
<p class="text-muted">This functionality enables you to generate a 3D topology image of the scenario. The grey nodes are
    the ones that are not online. The image is generated below automatically.</p>
<div id="3d-graph-container" class="row" style="width: 100%">
    <div id="3d-graph" style="width: 100%"></div>
</div>

<style>
    #map {
        position: relative;
        border: 1px solid black;
        border-radius: 8px;
        height: 400px;
        /* or as desired */
        width: 100%;
        /* This means "100% of the width of its container", the .col-md-8 */
    }

    .dropdown-content {
        background-color: #f9f9f9;
    }

    .ansi36 {
        color: blue;
        font-weight: bold;
    }

    #logicon {
        margin-right: 5px;
        margin-left: 2px;
    }
</style>

<script>
    var downloadLinks = document.getElementsByClassName('download');
    // Loop through the tags and add event listeners. When user click to a tag, do a fetch request to the link and get the response. If the response is 200, then the file exists and the link is enabled. If the response is 404, then the file does not exist and the link is disabled.
    for (var i = 0; i < downloadLinks.length; i++) {
        downloadLinks[i].addEventListener('click', function (e) {
            e.preventDefault();
            var link = this;
            fetch(link.href)
                .then(function (response) {
                    if (!response.ok) {
                        // If the file is not found, display the alert
                        showAlert('danger', 'File not found');
                    } else {
                        // If the file is found, redirect to it
                        window.location.href = link.href;
                    }
                });
        });
    }

</script>

<script>
    var logicons = document.querySelectorAll("#logicon");
    // Get the icon element
    logicons.forEach(function (logicon) {
        // Attack the checkbox event
        logicon.addEventListener("change", function (event) {
            // Get the checkbox
            var checkbox = event.target;
            // Get the row
            // var row = checkbox.parentNode.parentNode.parentNode.parentNode.parentNode;
            var row = checkbox.closest('tr');
            // Get the dropdown content
            var dropdownContent = row.nextElementSibling;
            // Toggle the dropdown content
            dropdownContent.style.display = dropdownContent.style.display === "none" ? "table-row" : "none";
            // Toggle the icon
            //icon.className = icon.className === "fa fa-caret-down" ? "fa fa-caret-right" : "fa fa-caret-down";
        });
    });
</script>

{% if False %}
<script>
    // If dropdown is open, get logscontainer and get the logs every 5 seconds
    // If not, not get the logs
    setInterval(function () {
        var dropdowns = document.querySelectorAll(".dropdown-content");
        dropdowns.forEach(function (dropdown) {
            if (dropdown.style.display === "table-row") {
                var logscontainer = dropdown.querySelector("#logscontainer");
                var participant_id = logscontainer.getAttribute("data-id");
                var scenario = logscontainer.getAttribute("data-scenario");
                fetch('/scenario/' + scenario + '/node/' + participant_id + '/infolog/10')
                    .then(function (response) {
                        if (!response.ok) {
                            console.log("Error");
                            return;
                        }
                        // Examine the text in the response (is not a json file)
                        response.text().then(function (data) {
                            // Change \n to <br>
                            data = data.replace(/\n/g, "<br>");
                            // Change ANSI color to HTML color
                            data = data.replace(/\x1b\[36m/g, "<span class='ansi36'>");
                            data = data.replace(/\x1b\[0m/g, "</span>");
                            // Change the text
                            logscontainer.innerHTML = data;
                        });
                    });
            }
        });
    }, 2000);
</script>
{% endif %}

<script>
    var map = L.map('map').setView([44.194021, 0.397141], 4);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; <a href=\"https://enriquetomasmb.com\">enriquetomasmb.com</a>' }).addTo(map);

    //{{ markers | safe }}

</script>

<script>
    const width = document.getElementById('3d-graph').offsetWidth;
    // When resize the window, resize the graph
    window.addEventListener("resize", function () {
        Graph.width(document.getElementById('3d-graph').offsetWidth);
    });

    const offlineNodes = new Set();

    const Graph = ForceGraph3D()
        (document.getElementById('3d-graph'))
        .width(width)
        .height(700)
        .backgroundColor('#ffffff')
        .nodeId('ipport')
        .nodeLabel(node => `<p style="color: black">ID: ${node.id} | IP: ${node.ipport} | Role: ${node.role}</p>`)
        .onNodeClick(node => {
            const distance = 40;
            const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);
            const newPos = node.x || node.y || node.z
                ? { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }
                : { x: 0, y: 0, z: distance }; // special case if node is in (0,0,0)
            Graph.cameraPosition(
                newPos, // new position
                node, // lookAt ({ x, y, z })
                3000  // ms transition duration
            )
        })
        //.linkSource('source')
        //.linkTarget('target')

        .nodeColor(node => offlineNodes.has(node.ipport) ? 'grey' :
            (node.role === "trainer" ? '#0173B2'
                : (node.role === "aggregator" ? 'rgba(255,136,0,0.6)'
                    : (node.role === "evaluator" ? '#F44336' : undefined))))
        .linkColor(link => link.color ? 'red' : 'black')
        .linkOpacity(0.6)
        .linkWidth(0.3)
        .linkDirectionalParticles("value")
        .linkDirectionalParticleSpeed(d => d.value * 0.001)
        .linkDirectionalParticleWidth(1);

    Graph.cameraPosition({ x: 0, y: 0, z: 70 }, { x: 0, y: 0, z: 0 }, 0);
    document.getElementsByClassName("scene-nav-info")[0].innerHTML = "Only visualization purpose. Click on a node to zoom in.";
</script>

<script>
    function updateGraph(gData) {
        // Global update of the graph
        //gDataUpdate(gData);
        Graph.graphData(gData);
    }

    function gDataUpdate(gData) {
        console.log("gDataUpdate");
        console.log(gData);
        // Remove duplicated links
        for (var i = 0; i < gData.links.length; i++) {
            for (var j = i + 1; j < gData.links.length; j++) {
                if ((gData.links[i].source === gData.links[j].source && gData.links[i].target === gData.links[j].target) ||
                    gData.links[i].source === gData.links[j].target && gData.links[i].target === gData.links[j].source) {
                    gData.links.splice(j, 1);
                }
            }
        }
    }
</script>

<script>
    function randomFloatFromInterval(min, max) { // min and max included
        return Math.random() * (max - min + 1) + min;
    }

    var initizalization = false;

    let gData = {
        nodes: [],
        links: []
    };

    // Get all divs with id "node-vars" and update them with value returned by async GET request
    var scenario_name = document.getElementById('scenario_name').innerHTML;
    var node_row = document.querySelectorAll("#node-vars");

    // Get the table
    fetch('/api/scenario/' + scenario_name + '/monitoring')
        .then(function (response) {
            if (!response.ok) {
                showAlert("danger", "Error: " + response.status + " " + response.statusText);
                return;
            }
            // Examine the json in the response
            response.json().then(function (data) {
                // Update the table with the values of the json and maintain the style of HTML
                var markers = Array();
                var markers_neighborhood = Array();
                var latlngs = Array();
                var nodes_offline = Array();

                data['nodes_table'].forEach(function (node) {
                    for (var i = 0; i < node_row.length; i++) {
                        var uid_row = node_row[i].querySelector("#uid").innerHTML.trim();
                        if (uid_row === node[0]) {
                            node_row[i].querySelector("#idx").innerHTML = node[1];
                            node_row[i].querySelector("#ip").innerHTML = node[2];
                            node_row[i].querySelector("#port").innerHTML = node[3];
                            node_row[i].querySelector("#role").innerHTML = node[4];
                            node_row[i].querySelector("#neighbors").innerHTML = node[5];
                            node_row[i].querySelector("#latitude").innerHTML = node[6];
                            node_row[i].querySelector("#longitude").innerHTML = node[7];
                            node_row[i].querySelector("#timestamp").innerHTML = node[8];
                            node_row[i].querySelector("#federation").innerHTML = node[9];
                            node_row[i].querySelector("#round").innerHTML = node[10];
                            if (node[12]) {
                                node_row[i].querySelector("#status").innerHTML = '<span class="label label-success">Online</span>';
                            } else {
                                nodes_offline.push(node[2] + ":" + node[3]);
                                offlineNodes.add(node[2] + ":" + node[3]);
                                node_row[i].querySelector("#status").innerHTML = '<span class="label label-danger">Offline</span>';
                            }
                            break;
                        }
                    }
                    if (!initizalization || Graph.graphData().nodes.length < data['nodes_table'].length) {
                        var markerExists = false;

                        map.eachLayer(function (layer) {
                            if (layer instanceof L.Marker) {
                                if (layer.options.title === node[0] && layer._latlng.lat === node[6] && layer._latlng.lng === node[7]) {
                                    markerExists = true;
                                } else if (layer.options.title === node[0] && (layer._latlng.lat !== node[6] || layer._latlng.lng !== node[7])) {
                                    map.removeLayer(layer);
                                }
                            } else if (layer instanceof L.Polyline) {
                                map.removeLayer(layer);
                            }
                        });
                        if (!markerExists) {
                            var marker = L.marker([node[6], node[7]], { title: node[2] + ':' + node[3] }).addTo(map)
                            marker.bindPopup('UID: ' + node[0] + '<br>IP:' + node[2] + ':' + node[3] + '<br>CLUSTER: Spain-Switzerland');
                        }
                    }
                });

                data['nodes_table'].forEach(function (node) {
                    var marker = L.marker([node[6], node[7]], { title: node[2] + ':' + node[3] })
                    var neighborhood = data['nodes_table'].filter(n => n[5].includes(node[2] + ":" + node[3]));
                    neighborhood.forEach(function (n) {
                        var marker_nei = L.marker([n[6], n[7]], { title: n[2] + ':' + n[3] })
                        // L.polyline([marker.getLatLng(), marker_nei.getLatLng()], { color: 'red', opacity: 0.2, smoothFactor: 1 }).addTo(map);
                    });
                });

                // Add data to the Graph topology
                // Check if there are new nodes to add to the graph
                if (!initizalization || Graph.graphData().nodes.length < data['nodes_table'].length) {
                    gData = {
                        // if data['nodes_table'][i][0] is not in nodes_offline, then add the node to the graph
                        nodes: data['nodes_table'].map(node => ({
                            id: node[1],
                            ip: node[2],
                            port: node[3],
                            ipport: node[2] + ":" + node[3],
                            role: node[4],
                            color: offlineNodes.has(node[2] + ":" + node[3]) ? 'grey' :
                                (node[4] === "trainer" ? '#0173B2'
                                    : (node[4] === "aggregator" ? 'rgba(255,136,0,0.6)'
                                        : (node[4] === "evaluator" ? '#F44336' : undefined))),
                        })),
                        links: data['nodes_table'].map(node => {
                            var links = [];
                            if (node[5] !== "") {
                                var neighbors = node[5].split(" ");
                                neighbors.forEach(function (neighbor) {
                                    links.push({
                                        source: node[2] + ":" + node[3],
                                        target: neighbor,
                                        value: offlineNodes.has(node[2] + ":" + node[3]) || offlineNodes.has(neighbor) ? 0 : randomFloatFromInterval(1.0, 1.3),
                                    });
                                });
                            }
                            return links;
                        }).flat()
                    };

                    // cross-link node objects
                    console.log(gData);
                    updateGraph(gData);
                }

                if (!initizalization) {
                    initizalization = true;
                }

            });
        })
</script>

<script>
    function randomFloatFromInterval(min, max) { // min and max included
        return Math.random() * (max - min + 1) + min;
    }

    function updateNode(nodeData) {
        // Get row (node-{uid}) using nodeData.uid and update the row with the values of nodeData
        var node_row = document.querySelectorAll("#node-" + nodeData.uid);
        node_row[0].querySelector("#idx").innerHTML = nodeData.idx;
        node_row[0].querySelector("#ip").innerHTML = nodeData.ip;
        node_row[0].querySelector("#port").innerHTML = nodeData.port;
        node_row[0].querySelector("#role").innerHTML = nodeData.role;
        node_row[0].querySelector("#neighbors").innerHTML = nodeData.neighbors;
        node_row[0].querySelector("#latitude").innerHTML = nodeData.latitude;
        node_row[0].querySelector("#longitude").innerHTML = nodeData.longitude;
        node_row[0].querySelector("#timestamp").innerHTML = nodeData.timestamp;
        node_row[0].querySelector("#federation").innerHTML = nodeData.federation;
        node_row[0].querySelector("#round").innerHTML = nodeData.round;
        // Request /api/scenario/{{ scenario_name }}/monitoring to get only the status of the node
        fetch('/api/scenario/' + nodeData.scenario_name + '/monitoring')
            .then(function (response) {
                if (!response.ok) {
                    showAlert("danger", "Error: " + response.status + " " + response.statusText);
                    return;
                }
                // Examine the json in the response
                response.json().then(function (data) {
                    data['nodes_table'].forEach(function (node) {
                        if (node[0] === nodeData.uid) {
                            node_row[0].querySelector("#status").innerHTML = node[12] ? '<span class="label label-success">Online</span>' : '<span class="label label-danger">Offline</span>';
                        }
                    });
                });
            });
        
        // Update the map
        // Remove the old marker
        map.eachLayer(function (layer) {
            if (layer instanceof L.Marker) {
                if (layer.options.title === nodeData.ip + ':' + nodeData.port) {
                    map.removeLayer(layer);
                }
            }
        });
        // Add the new marker if it is not already in the map
        var marker = L.marker([nodeData.latitude, nodeData.longitude], { title:  nodeData.ip + ':' + nodeData.port }).addTo(map)
        marker.bindPopup('UID: ' + nodeData.uid + '<br>IP:' + nodeData.ip + ':' + nodeData.port + '<br>CLUSTER: Spain-Switzerland');
        
        // Add the new marker and its neighborhood to the map
        //var marker = L.marker([nodeData.latitude, nodeData.longitude], { title:  nodeData.ip + ':' + nodeData.port })
        //console.log("Marker11");
        //console.log(marker);
        //var neighborhood = nodeData.neighbors.split(" ");
        //neighborhood.forEach(function (n) {
            // Create a polyline between the node and its neighbors (other markers)
        //    map.eachLayer(function (layer) {
        //        if (layer instanceof L.Marker) {
        //            console.log(layer);
        //            if (layer.options.title === n) {
        //                var marker_nei = L.marker([layer._latlng.lat, layer._latlng.lng], { title: n })
        //                L.polyline([marker.getLatLng(), marker_nei.getLatLng()], { color: 'red', opacity: 0.2, smoothFactor: 1 }).addTo(map);
        //            }
         //       }
        //    });
        //});

    }



</script>

<script type="text/javascript">
    // Check if WebSocket is supported by the browser
    if ("WebSocket" in window) {
        console.log("WebSocket is supported by your Browser!");
    } else {
        console.log("WebSocket NOT supported by your Browser!");
    }

    // If url is http io.connect() should be used with http, if url is https io.connect() should be used with https
    if (window.location.protocol === 'https:') {
        var socket = io.connect('https://' + document.domain + ':' + location.port);
    } else {
        var socket = io.connect('http://' + document.domain + ':' + location.port);
    }

    socket.on('node_update', function (data) {
        console.log("Received node_update from WebSocket");
        console.log(data);

        console.log("gData before updating the node");
        console.log(gData);

        // Update the table and the map
        updateNode(data);
        
        // Update the graph
        // Add the new node to the gData and update the graph (if the node is not already in the graph)
        var nodeExists = false;
        for (var i = 0; i < gData.nodes.length; i++) {
            // Check if the node is already in the graph (using ip:port)
            if (gData.nodes[i].ipport === data.ip + ":" + data.port) {
                nodeExists = true;
                break;
            }
        }
        if (!nodeExists) {
            console.log("Adding new node to the graph")
            showAlert("success", "New node added to the graph");
            gData.nodes.push({
                id: data.idx,
                ip: data.ip,
                port: data.port,
                ipport: data.ip + ":" + data.port,
                role: data.role,
                color: offlineNodes.has(data.ip + ":" + data.port) ? 'grey' :
                    (data.role === "trainer" ? '#7570b3'
                        : (data.role === "aggregator" ? '#d95f02' : undefined)),
            });
            // Create a link between the new node and its neighbors
            var links = [];
            if (data.neighbors !== "") {
                var neighbors = data.neighbors.split(" ");
                neighbors.forEach(function (neighbor) {
                    links.push({
                        source: data.ip + ":" + data.port,
                        target: neighbor,
                        value: offlineNodes.has(data.ip + ":" + data.port) || offlineNodes.has(neighbor) ? 0 : randomFloatFromInterval(1.0, 1.3),
                    });
                });
            }
            gData.links.push(links);
            // Update the graph
            console.log("gData after adding the new node");
            console.log(gData);
            updateGraph(gData);
        } else {
            console.log("Node already exists in the graph")
        }

        // Detect if the data.node has different neighbors in the graph, then remove the links that are not in the new neighbors
        console.log("Detecting if the node has different neighbors");
        var node = gData.nodes.filter(n => n.ipport === data.ip + ":" + data.port)[0];
        console.log("Node in the graph using event received from WebSocket");
        console.log(node);
        var neighbors = data.neighbors.split(" ");
        console.log("Neighbors in the event received from WebSocket");
        console.log(neighbors);
        console.log("gData.links");
        console.log(gData.links);
        var linksToRemove = [];
        // Identify the links to remove, the new neighbors are in neighbors. If a link is not in neighbors, then remove it
        // Compare both source and target because the links are bidirectional
        for (var i = 0; i < gData.links.length; i++) {
            console.log(gData.links[i])
            if (gData.links[i].source.ipport === node.ipport && !neighbors.includes(gData.links[i].target.ipport)) {
                linksToRemove.push(gData.links[i]);
            } else if (gData.links[i].target.ipport === node.ipport && !neighbors.includes(gData.links[i].source.ipport)) {
                linksToRemove.push(gData.links[i]);
            }
        }
        console.log("Links to remove");
        console.log(linksToRemove);
        // Remove the links
        for (var i = 0; i < linksToRemove.length; i++) {
            for (var j = 0; j < gData.links.length; j++) {
                if (gData.links[j].source.ipport === linksToRemove[i].source.ipport && gData.links[j].target.ipport === linksToRemove[i].target.ipport) {
                    gData.links.splice(j, 1);
                    showAlert("warning", "Link removed from the graph")
                } else if (gData.links[j].source.ipport === linksToRemove[i].target.ipport && gData.links[j].target.ipport === linksToRemove[i].source.ipport) {
                    gData.links.splice(j, 1);
                    showAlert("warning", "Link removed from the graph")
                }
            }
        }
        // Update the graph
        console.log(gData);
        updateGraph(gData);


    });

    socket.on('node_delete', function (data) {
        console.log("Received node_delete from WebSocket");
        console.log(data);
        // data has the following format: {"node": self.__self_addr, "neighbor": nei}, where nei is the neighbor that has been deleted
        // Remove the link between the node and its neighbor
        for (var i = 0; i < gData.links.length; i++) {
            if (gData.links[i].source === data.node && gData.links[i].target === data.neighbor) {
                gData.links.splice(i, 1);
                break;
            }
        }
        // Update the graph
        console.log(gData);
        updateGraph(gData);
    });
</script>

{% endif %}
{% endblock %}